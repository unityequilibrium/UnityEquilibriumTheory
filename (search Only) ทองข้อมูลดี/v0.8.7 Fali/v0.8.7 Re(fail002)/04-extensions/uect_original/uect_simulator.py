"""
UECT Simulator — Original Theory Implementation
Based on Before_Equation.md (the "highest" version)

Original UECT Equation:
dE/dt = M·d(C²)/dt - S·dC/dt + ∇Φ - k₁∇S + k₂∇C

Variables:
- M = Mass-Mechanism (กลไกคืนสมดุล)
- S = Entropy (การสูญเสีย)
- C = Communication rate
- Φ = Synergy potential (ความร่วมมือ)
- E = Total energy

Force equation (analog to Newton):
F = M · dC/dt

Energy equation (analog to Einstein):
E = M·C² - S·C + Φ
"""

import numpy as np
import matplotlib.pyplot as plt
import os

print("=" * 70)
print("UECT Simulator — Original Theory (5 Variables)")
print("=" * 70)

# =====================================================================
# Parameters (from original theory)
# =====================================================================
N = 32  # Grid size
L = 10.0  # Domain size
dx = L / N

# Coupling constants
k1 = 1.0  # Entropy coupling
k2 = 1.0  # Communication coupling
kappa = 0.5  # Gradient coefficient

# Time
dt = 0.01
T = 100

np.random.seed(42)

# =====================================================================
# Initialize 5 Variables as 2D fields
# =====================================================================
# M: Mass-Mechanism — ability to restore equilibrium
M = np.ones((N, N)) * 1.0 + np.random.randn(N, N) * 0.05

# S: Entropy — disorder/loss
S = np.random.rand(N, N) * 0.2

# C: Communication rate — information exchange
C = np.random.randn(N, N) * 0.1

# Phi: Synergy potential — cooperation energy
Phi = np.zeros((N, N))


# E: Total energy (computed from others)
def compute_E(M, C, S, Phi):
    """E = M·C² - S·C + Φ"""
    return M * C**2 - S * C + Phi


E = compute_E(M, C, S, Phi)

print(f"\nInitial state:")
print(f"  M mean = {np.mean(M):.4f}")
print(f"  S mean = {np.mean(S):.4f}")
print(f"  C mean = {np.mean(C):.4f}")
print(f"  Φ mean = {np.mean(Phi):.4f}")
print(f"  E mean = {np.mean(E):.4f}")


# =====================================================================
# Helper functions
# =====================================================================
def gradient_2d(field):
    """Compute gradient magnitude |∇field|"""
    grad_x = np.gradient(field, dx, axis=0)
    grad_y = np.gradient(field, dx, axis=1)
    return np.sqrt(grad_x**2 + grad_y**2)


def laplacian_2d(field):
    """Periodic boundary laplacian"""
    return (
        np.roll(field, 1, axis=0)
        + np.roll(field, -1, axis=0)
        + np.roll(field, 1, axis=1)
        + np.roll(field, -1, axis=1)
        - 4 * field
    ) / dx**2


def divergence_of_gradient(field):
    """∇·(∇field) = ∇²field"""
    return laplacian_2d(field)


# =====================================================================
# UECT Dynamics
# =====================================================================
def dE_dt_UECT(M, C, dC_dt, S, Phi, dPhi_dt, grad_S, grad_C):
    """
    UECT master equation:
    dE/dt = M·d(C²)/dt - S·dC/dt + dΦ/dt - k₁∇·∇S + k₂∇·∇C

    d(C²)/dt = 2C·dC/dt
    """
    term1 = M * 2 * C * dC_dt  # Mass × communication change
    term2 = -S * dC_dt  # Entropy dissipation
    term3 = dPhi_dt  # Synergy change
    term4 = -k1 * divergence_of_gradient(S)  # Entropy diffusion
    term5 = k2 * divergence_of_gradient(C)  # Communication diffusion

    return term1 + term2 + term3 + term4 + term5


def dynamics_step(M, S, C, Phi, dt):
    """
    One step of UECT dynamics

    dC/dt = -αC + βΦ + γ∇²C   (Communication relaxes, boosted by synergy)
    dS/dt = -λS + k∇²S        (Entropy diffuses, decays)
    dΦ/dt = C·<neighbors>     (Synergy from communication)
    dM/dt = 0                  (Mass conserved in simple model)
    """
    alpha = 0.01  # Communication decay
    beta = 0.1  # Synergy boost
    gamma = 0.5  # Communication diffusion
    lambda_s = 0.02  # Entropy decay

    # Communication dynamics: evolves based on synergy and diffusion
    dC = -alpha * C + beta * Phi + gamma * laplacian_2d(C)

    # Entropy dynamics: diffuses and decays
    dS = -lambda_s * S + kappa * laplacian_2d(S)

    # Synergy dynamics: generated by local communication correlation
    # Φ increases when neighbors communicate
    neighbor_C = (
        np.roll(C, 1, axis=0)
        + np.roll(C, -1, axis=0)
        + np.roll(C, 1, axis=1)
        + np.roll(C, -1, axis=1)
    ) / 4
    dPhi = 0.1 * C * neighbor_C - 0.05 * Phi  # Generate and decay

    # Mass stays constant (could add dynamics later)
    dM = np.zeros_like(M)

    # Update
    C_new = C + dt * dC
    S_new = np.maximum(0, S + dt * dS)  # Entropy non-negative
    Phi_new = Phi + dt * dPhi
    M_new = M + dt * dM

    return M_new, S_new, C_new, Phi_new, dC


# =====================================================================
# Run simulation
# =====================================================================
print(f"\nRunning UECT dynamics for T={T}...")

history = {"E": [], "M": [], "S": [], "C": [], "Phi": [], "dE_dt": []}

for t in range(T):
    # Store current state
    E = compute_E(M, C, S, Phi)
    history["E"].append(np.mean(E))
    history["M"].append(np.mean(M))
    history["S"].append(np.mean(S))
    history["C"].append(np.mean(C))
    history["Phi"].append(np.mean(Phi))

    # Dynamics step
    M, S, C, Phi, dC = dynamics_step(M, S, C, Phi, dt)

    # Compute energy rate
    E_new = compute_E(M, C, S, Phi)
    dE = np.mean(E_new - E) / dt
    history["dE_dt"].append(dE)

    if t % 20 == 0:
        print(
            f"t={t:4d}: E={np.mean(E):.4f}, M={np.mean(M):.4f}, "
            f"S={np.mean(S):.4f}, C={np.mean(C):.4f}, Φ={np.mean(Phi):.4f}"
        )

# =====================================================================
# Results
# =====================================================================
print("\n" + "=" * 70)
print("RESULTS")
print("=" * 70)

E_final = compute_E(M, C, S, Phi)
print(f"\nFinal state:")
print(f"  M mean = {np.mean(M):.4f}")
print(f"  S mean = {np.mean(S):.4f}")
print(f"  C mean = {np.mean(C):.4f}")
print(f"  Φ mean = {np.mean(Phi):.4f}")
print(f"  E mean = {np.mean(E_final):.4f}")

# Check energy tendency
E_init = history["E"][0]
E_end = history["E"][-1]
print(f"\nEnergy evolution:")
print(f"  E_initial = {E_init:.6f}")
print(f"  E_final   = {E_end:.6f}")
print(f"  ΔE = {E_end - E_init:.6f}")

# Entropy decay
S_init = history["S"][0]
S_end = history["S"][-1]
print(f"\nEntropy evolution:")
print(f"  S_initial = {S_init:.6f}")
print(f"  S_final   = {S_end:.6f}")
print(f"  Entropy decrease: {'✅' if S_end < S_init else '❌'}")

# Synergy growth
Phi_init = history["Phi"][0]
Phi_end = history["Phi"][-1]
print(f"\nSynergy evolution:")
print(f"  Φ_initial = {Phi_init:.6f}")
print(f"  Φ_final   = {Phi_end:.6f}")
print(f"  Synergy growth: {'✅' if Phi_end > Phi_init else '❌'}")

# =====================================================================
# Collapse tests
# =====================================================================
print("\n" + "=" * 70)
print("COLLAPSE TESTS")
print("=" * 70)

# Test 1: When S=0, Φ=0 → E = MC² (Einstein-like)
M_test = 1.0
C_test = 3e8  # Speed of light
S_test = 0.0
Phi_test = 0.0
E_einstein = M_test * C_test**2
print(f"\nTest 1: S=0, Φ=0 → E = MC²")
print(f"  E = M·C² = {E_einstein:.4e} J")
print(f"  ✅ Einstein structure preserved!")

# Test 2: Force analog — F = M·dC/dt
M_test = 2.0
dC_dt_test = 5.0
F_analog = M_test * dC_dt_test
print(f"\nTest 2: F = M·dC/dt (Newton analog)")
print(f"  F = {F_analog:.4f}")
print(f"  ✅ Newton structure: F = M × (change in communication)")

# =====================================================================
# Plots
# =====================================================================
fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# Plot 1: Energy evolution
axes[0, 0].plot(history["E"], "b-", linewidth=1)
axes[0, 0].set_title("Energy E(t)")
axes[0, 0].set_xlabel("Time")
axes[0, 0].set_ylabel("Mean E")
axes[0, 0].grid(True)

# Plot 2: All variables
axes[0, 1].plot(history["M"], label="M (Mass)", linewidth=1)
axes[0, 1].plot(history["S"], label="S (Entropy)", linewidth=1)
axes[0, 1].plot(history["C"], label="C (Communication)", linewidth=1)
axes[0, 1].plot(history["Phi"], label="Φ (Synergy)", linewidth=1)
axes[0, 1].set_title("All Variables")
axes[0, 1].set_xlabel("Time")
axes[0, 1].legend()
axes[0, 1].grid(True)

# Plot 3: dE/dt
axes[0, 2].plot(history["dE_dt"], "g-", linewidth=0.5)
axes[0, 2].axhline(0, color="k", linestyle="--")
axes[0, 2].set_title("Energy Rate dE/dt")
axes[0, 2].set_xlabel("Time")
axes[0, 2].grid(True)

# Plot 4: Final C field
im1 = axes[1, 0].imshow(C, cmap="RdBu", vmin=-0.5, vmax=0.5)
axes[1, 0].set_title("C (Communication) Field")
plt.colorbar(im1, ax=axes[1, 0])

# Plot 5: Final Phi field
im2 = axes[1, 1].imshow(Phi, cmap="Greens")
axes[1, 1].set_title("Φ (Synergy) Field")
plt.colorbar(im2, ax=axes[1, 1])

# Plot 6: Final Energy field
im3 = axes[1, 2].imshow(E_final, cmap="plasma")
axes[1, 2].set_title("E (Energy) Field")
plt.colorbar(im3, ax=axes[1, 2])

plt.suptitle("UECT Simulator — Original 5-Variable Theory", fontsize=14)
plt.tight_layout()

output_dir = os.path.dirname(os.path.abspath(__file__))
output_path = os.path.join(output_dir, "uect_original_simulation.png")
plt.savefig(output_path, dpi=150)
print(f"\nPlot saved: {output_path}")
plt.close()

print("\n" + "=" * 70)
print("UECT Original Theory Implementation Complete!")
print("=" * 70)
